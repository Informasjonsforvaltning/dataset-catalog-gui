"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCorrectFileFormat = exports.FileUploader = void 0;

var React = _interopRequireWildcard(require("react"));

var _axios = _interopRequireDefault(require("axios"));

var _i18n = _interopRequireWildcard(require("./../utils/i18n/i18n"));

var _FileUploader = require("./FileUploader.classNames");

var _classnames = _interopRequireDefault(require("classnames"));

var _ErrorMessage = require("../ErrorMessage");

var _Spinner = require("../Spinner");

var _Icon = require("../Icon");

var _LabelWithCallout = require("../LabelWithCallout");

var _Link = require("../Link");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const isCorrectFileFormat = (file, acceptedFilformats) => {
  if (!acceptedFilformats) {
    return true;
  }

  const fileExtention = file.name.toLowerCase().match(/\.[0-9a-z]+$/i);

  if (fileExtention && fileExtention[0]) {
    if (acceptedFilformats.indexOf(fileExtention[0]) > -1) {
      return true;
    }
  }

  return false;
};

exports.isCorrectFileFormat = isCorrectFileFormat;
const nonWordCharacterRegexp = /\W/g;
const fileNameRegex = /\.(?=[^.]+$)/;

const normalize = (file, invalidCharacterRegexp) => {
  const nameList = file.name.split(fileNameRegex);
  const fileName = nameList[0];
  const normalizedName = fileName.replace(invalidCharacterRegexp || nonWordCharacterRegexp, '_');
  return normalizedName.concat('.', nameList[1]);
};

var FilTyperNavn;

(function (FilTyperNavn) {
  FilTyperNavn["ExcelFile"] = "ExcelFile";
  FilTyperNavn["WordFile"] = "WordFile";
  FilTyperNavn["PDFFile"] = "PDFFile";
  FilTyperNavn["XMLFile"] = "XMLFile";
  FilTyperNavn["File"] = "File";
})(FilTyperNavn || (FilTyperNavn = {}));

const filtypeMap = (() => {
  const map = new Map();
  map.set('xls', FilTyperNavn.ExcelFile);
  map.set('xlsx', FilTyperNavn.ExcelFile);
  map.set('doc', FilTyperNavn.WordFile);
  map.set('docx', FilTyperNavn.WordFile);
  map.set('pdf', FilTyperNavn.PDFFile);
  map.set('xml', FilTyperNavn.XMLFile);
  return map;
})();

const getFileIconName = fil => {
  const filutvidelse = fil.name.toLowerCase().split('.').pop();
  const fileType = filtypeMap.get(filutvidelse ? filutvidelse : '');
  return fileType ? fileType : FilTyperNavn.File;
};

const FileUploader = props => {
  const {
    acceptedFileFormats,
    acceptedFileFormatsLabel,
    addFileString,
    afterUpload,
    axiosPath,
    className,
    deleteAllFiles,
    deleteButtonAriaLabel,
    deleteFile,
    exceedFileSizeLimitErrorMessage,
    files,
    fileSizeLimit,
    help,
    id,
    info,
    required = false,
    invalidCharacterRegexp,
    isLoading,
    label,
    labelButtonAriaLabel,
    labelWithCalloutProps,
    language,
    loading,
    multipleFiles,
    normalizeFileName,
    onCalloutToggle,
    queryParams,
    uploadFile,
    downloadFile
  } = props;
  const styles = (0, _FileUploader.getClassNames)(props);
  const [internalFiles, setInternalFiles] = (0, React.useState)(files ? files : []);
  const [internalErrorMessages, setInternalErrorMessages] = (0, React.useState)([]);
  const [internalLoading, setInternalLoading] = (0, React.useState)(false);
  const inputRef = (0, React.useRef)(null);
  const uploadAreaRef = (0, React.useRef)(null);
  const randomId = (0, _utils.generateId)();
  const mainId = id ?? 'fileupload-' + randomId;
  const calloutId = mainId + '-callout';
  const fileuploadLabelId = mainId + '-label';
  const acceptedFileFormatsId = mainId + '-acceptedFileFormats';
  const informationId = mainId + '-information';

  if (language) {
    _i18n.default.changeLanguage(language);
  }

  (0, React.useEffect)(() => {
    if (files) {
      setInternalFiles(files);
    }
  }, [files]);

  const pushToInternalMessages = msg => setInternalErrorMessages(prevState => [...prevState, msg]);

  const handleFileChange = event => {
    event.preventDefault();
    event.stopPropagation();

    if (event.target.files && event.target.files.length > 0) {
      handleNewFiles(Array.from(event.target.files));
    } // Må set input verdi til "" så at det er mulig å opplaste samme fil etter den blir fjernes i Chrome


    event.target.value = '';
  };

  const triggerUpdateFiles = validFiles => {
    if (uploadFile) {
      validFiles.forEach(file => {
        uploadFile(file);
      });
    }
  };

  const uploadFilePromise = (url, file, params) => {
    const formData = new FormData();
    formData.append('upload', file, normalizeFileName ? normalize(file, invalidCharacterRegexp) : undefined);
    return _axios.default.post(url, formData, {
      params
    });
  };

  const isValidFile = (file, sizeLimit) => isCorrectFileFormat(file, acceptedFileFormats) && (sizeLimit ? file.size <= sizeLimit : true);

  const handleNewFiles = fileList => {
    setInternalErrorMessages([]);
    const exceedSizeLimitFiles = fileSizeLimit ? fileList.filter(file => file.size > fileSizeLimit) : [];

    if (fileSizeLimit && exceedSizeLimitFiles.length) {
      pushToInternalMessages(exceedFileSizeLimitErrorMessage || createDefaultOversizedFileErrorMessage(fileSizeLimit));
    }

    const invalidFileFormatFiles = fileList.filter(file => !isCorrectFileFormat(file, acceptedFileFormats));

    if (invalidFileFormatFiles.length) {
      pushToInternalMessages((0, _i18n.t)('fileuploader.error.file_format'));
    }

    const validFiles = fileList.filter(file => isValidFile(file, fileSizeLimit));
    triggerUpdateFiles(validFiles);

    if (!axiosPath) {
      return;
    }

    if (validFiles && validFiles.length) {
      setInternalLoading(true);
      const allPromises = validFiles.map(file => uploadFilePromise(axiosPath, file, queryParams));
      setTimeout(() => {
        _axios.default.all(allPromises).then(responses => {
          const updatedInternalFiles = [...internalFiles, ...responses.map(res => res.data)];
          setInternalFiles(updatedInternalFiles);

          if (afterUpload) {
            afterUpload(updatedInternalFiles);
          }
        }).catch(error => {
          //TODO: Det trenger design om flere feilmeldinger
          if (error.response && error.response.status === 403) {
            pushToInternalMessages((0, _i18n.t)('fileuploader.error.upload.403'));
          } else {
            pushToInternalMessages((0, _i18n.t)('fileuploader.error.upload.general'));
          }

          if (afterUpload) {
            afterUpload(internalFiles);
          }
        }).finally(() => {
          setInternalLoading(false);
        });
      }, props.forsinkelse || 0);
    }
  };

  const createDefaultOversizedFileErrorMessage = filstoerrelsegrense => _i18n.default.t('fileuploader.error.file_size', {
    filstoerrelsegrense: bitToMegabyte(filstoerrelsegrense)
  });

  const bitToMegabyte = size => (size / (1024 * 1024)).toFixed(1);

  const handleDragOverAndDragEnter = event => {
    event.preventDefault();
    event.stopPropagation();
  };

  const handleDragLeave = event => {
    event.preventDefault();
    event.stopPropagation();
  };

  const handleDrop = event => {
    event.preventDefault();
    event.stopPropagation();

    if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length > 0) {
      handleNewFiles(Array.from(event.dataTransfer.files));
    }
  };

  const showFileName = file => {
    if (downloadFile) {
      return /*#__PURE__*/React.createElement(_Link.Link, {
        tabIndex: 0,
        text: file.name,
        onClick: () => downloadFile(file)
      });
    } else {
      return /*#__PURE__*/React.createElement("span", null, file.name);
    }
  };

  const deleteFromList = fileToBeDeleted => {
    setInternalErrorMessages([]);

    if (axiosPath) {
      _axios.default.delete(`${axiosPath}/${fileToBeDeleted.id}`, {
        params: queryParams,
        data: props.usesWebSealCompatibleDelete === true ? null : {} // body kreves av BigIP

      }).then(() => {
        const newList = internalFiles.filter(f => f.id !== fileToBeDeleted.id);
        setInternalFiles(newList);
        triggerUpdateFiles(newList);
      }).catch(error => {
        if (error.response && error.response.status === 403) {
          pushToInternalMessages((0, _i18n.t)('fileuploader.error.delete.403'));
        } else {
          pushToInternalMessages((0, _i18n.t)('fileuploader.error.delete.general'));
        }
      }).finally(() => {
        if (deleteFile) {
          deleteFile(fileToBeDeleted, internalErrorMessages);
        }
      });
    } else {
      if (deleteFile) {
        deleteFile(fileToBeDeleted, internalErrorMessages);
      }
    }

    const ref = uploadAreaRef.current;

    if (ref) {
      ref.focus();
    }
  };

  if (deleteAllFiles && files) {
    files.forEach(file => {
      deleteFromList(file);
    });
  }

  (0, React.useEffect)(() => {
    isLoading && isLoading(loading || internalLoading);
  }, [loading, internalLoading, isLoading]);
  return /*#__PURE__*/React.createElement("div", {
    className: (0, _classnames.default)(styles.main, className)
  }, /*#__PURE__*/React.createElement(_LabelWithCallout.LabelWithCallout, _extends({
    id: calloutId + '-label',
    inputId: calloutId + '-input',
    label: label,
    requiredMark: required,
    buttonAriaLabel: labelButtonAriaLabel,
    help: help,
    onCalloutToggle: onCalloutToggle
  }, labelWithCalloutProps)), /*#__PURE__*/React.createElement("label", {
    id: fileuploadLabelId
  }, /*#__PURE__*/React.createElement("div", {
    ref: uploadAreaRef,
    className: styles.uploadArea,
    role: "button",
    "aria-describedby": fileuploadLabelId.concat(acceptedFileFormats ? ' '.concat(acceptedFileFormatsId) : '', info ? ' '.concat(informationId) : ''),
    tabIndex: 0,
    onDragEnter: handleDragOverAndDragEnter,
    onDragLeave: handleDragLeave,
    onDragOver: handleDragOverAndDragEnter,
    onDrop: handleDrop,
    onClick: event => {
      event.preventDefault();

      if (inputRef.current) {
        inputRef.current.click();
      }
    },
    onKeyPress: ev => {
      if (ev.keyCode === 0 && inputRef.current) {
        inputRef.current.click();
      }
    }
  }, loading || internalLoading ? /*#__PURE__*/React.createElement(_Spinner.Spinner, null) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(_Icon.Icon, {
    iconName: 'AttachFile',
    className: styles.uploadAreaIcon
  }), /*#__PURE__*/React.createElement("u", null, addFileString ? addFileString : (0, _i18n.t)('fileuploader.add.label'))))), /*#__PURE__*/React.createElement("input", {
    className: styles.fileUploadInput,
    type: "file",
    id: calloutId + '-input',
    ref: inputRef,
    multiple: multipleFiles,
    onChange: handleFileChange,
    tabIndex: -1,
    "aria-hidden": true
  }), acceptedFileFormats && /*#__PURE__*/React.createElement("span", {
    className: styles.informationWrapper,
    id: acceptedFileFormatsId
  }, acceptedFileFormatsLabel ? acceptedFileFormatsLabel : (0, _i18n.t)('fileuploader.accepted_file_formats'), ' ', /*#__PURE__*/React.createElement("span", {
    className: styles.acceptedFileFormats
  }, acceptedFileFormats.map((fileFormat, index) => {
    if (index === acceptedFileFormats.length - 1) {
      return fileFormat;
    } else {
      return fileFormat.concat(', ');
    }
  }))), info && /*#__PURE__*/React.createElement("div", {
    className: styles.informationWrapper,
    id: informationId
  }, info), internalErrorMessages && internalErrorMessages.map(msg => /*#__PURE__*/React.createElement("div", {
    key: msg
  }, /*#__PURE__*/React.createElement(_ErrorMessage.ErrorMessage, null, msg))), /*#__PURE__*/React.createElement("div", {
    role: "alert",
    "aria-atomic": "true",
    className: styles.fileListWrapper
  }, internalFiles.length > 0 && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
    className: "sr-only"
  }, (0, _i18n.t)('fileuploader.uploaded.sr_heading')), /*#__PURE__*/React.createElement("ul", {
    className: styles.fileList
  }, internalFiles.map((file, index) => /*#__PURE__*/React.createElement("li", {
    key: file.name.concat(index.toString())
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.fileName
  }, /*#__PURE__*/React.createElement(_Icon.Icon, {
    className: styles.fileIcon,
    iconName: getFileIconName(file)
  }), showFileName(file)), file.error ? /*#__PURE__*/React.createElement(_Icon.Icon, {
    iconName: 'Error',
    className: styles.errorColor
  }) : /*#__PURE__*/React.createElement("button", {
    className: styles.fileListCancelBtn,
    onClick: () => deleteFromList(file),
    "aria-label": deleteButtonAriaLabel ? deleteButtonAriaLabel : (0, _i18n.t)('fileuploader.delete.ariaLabel')
  }, /*#__PURE__*/React.createElement(_Icon.Icon, {
    iconName: 'Cancel'
  }))))))));
};

exports.FileUploader = FileUploader;