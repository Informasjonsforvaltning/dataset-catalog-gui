"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSlidingWindowEdges = exports.PreviousLink = exports.Pagination = exports.Pages = exports.Page = exports.NextPage = void 0;

var React = _interopRequireWildcard(require("react"));

var _Pagination = require("./Pagination.classNames");

var _classnames = _interopRequireDefault(require("classnames"));

var _Icon = require("../Icon");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const getNumberOfPages = (total, pageSize) => {
  return Math.ceil(total / pageSize);
};

const range = (start, end, pagesDisplayed) => [...new Array(pagesDisplayed < end ? pagesDisplayed : end)].filter((v, k) => !(k + start > end)).map((v, k) => k + start);

const getSlidingWindowEdges = (currentPage, total, pageSize, pagesDisplayed) => {
  const numberOfPages = getNumberOfPages(total, pageSize);

  if (numberOfPages <= pagesDisplayed) {
    return {
      startPage: 1,
      endPage: numberOfPages
    };
  }

  let startPage = currentPage - (pagesDisplayed - 1);

  if (currentPage <= pagesDisplayed) {
    startPage = 1;
  }

  let endPage = startPage + (pagesDisplayed - 1); // Funksjon for Ã¥ sette currentPage midt i sidevelger

  if (endPage === currentPage && !(endPage >= numberOfPages)) {
    const addValue = Math.floor(pagesDisplayed / 2);
    endPage = endPage + addValue;
    startPage = startPage + addValue;
  }

  if (endPage > numberOfPages) {
    endPage = numberOfPages;
  }

  return {
    startPage: startPage,
    endPage: endPage
  };
};
/*
 * visibleName Pagination (Sidevelger)
 */


exports.getSlidingWindowEdges = getSlidingWindowEdges;

const Pagination = props => {
  const {
    ariaLabel,
    ariaLabelNavigationLink,
    ariaLabelNavigationLinkActive,
    className,
    nextLabel,
    onPageChange,
    pagesDisplayed,
    previousLabel,
    total
  } = props;
  const styles = (0, _Pagination.getClassNames)();
  const [pageSize, setPageSize] = React.useState(props.pageSize);
  const [currentPage, setCurrentPage] = React.useState(props.currentPage);
  const firstListObject = (currentPage - 1) * pageSize;
  const lastListObject = Math.min(firstListObject + pageSize, total);
  React.useEffect(() => {
    setCurrentPage(props.currentPage);
  }, [props.currentPage]);
  React.useEffect(() => {
    if (pageSize !== props.pageSize) {
      setCurrentPage(1);
    }

    setPageSize(props.pageSize);
  }, [props.pageSize, pageSize]);
  const view = lastListObject > total ? total : firstListObject + 1 + '-' + lastListObject;
  return /*#__PURE__*/React.createElement("div", {
    className: (0, _classnames.default)(styles.paginationContainer, className)
  }, /*#__PURE__*/React.createElement("p", {
    "data-testid": "pagination-oppsummering"
  }, `Viser ${view} av ${total}`), /*#__PURE__*/React.createElement("nav", {
    "aria-label": ariaLabel ? ariaLabel : 'Sidenavigering'
  }, /*#__PURE__*/React.createElement("ul", null, currentPage > 1 && /*#__PURE__*/React.createElement(PreviousLink, {
    currentPage: currentPage,
    onClick: page => onPageChange(page),
    label: previousLabel ? previousLabel : 'Forrige'
  }), /*#__PURE__*/React.createElement("li", null, /*#__PURE__*/React.createElement("ul", null, /*#__PURE__*/React.createElement(Pages, {
    onPageChange: onPageChange,
    currentPage: currentPage,
    total: total,
    pagesDisplayed: pagesDisplayed,
    pageSize: pageSize,
    ariaLabelNavigationLink: ariaLabelNavigationLink,
    ariaLabelNavigationLinkActive: ariaLabelNavigationLinkActive
  }))), currentPage < getNumberOfPages(total, pageSize) && /*#__PURE__*/React.createElement(NextPage, {
    currentPage: currentPage,
    total: total,
    pageSize: pageSize,
    onClick: onPageChange,
    label: nextLabel ? nextLabel : 'Neste'
  }))));
};

exports.Pagination = Pagination;

const NextPage = props => {
  const styles = (0, _Pagination.getClassNames)();
  return /*#__PURE__*/React.createElement("li", null, /*#__PURE__*/React.createElement("button", {
    onClick: evt => {
      evt.preventDefault();
      props.onClick(props.currentPage + 1);
    },
    role: "link"
  }, /*#__PURE__*/React.createElement("span", null, props.label), /*#__PURE__*/React.createElement(_Icon.Icon, {
    iconName: "ChevronRight",
    className: styles.linkIcons
  })));
};

exports.NextPage = NextPage;

const PreviousLink = props => {
  const styles = (0, _Pagination.getClassNames)();
  return /*#__PURE__*/React.createElement("li", null, /*#__PURE__*/React.createElement("button", {
    onClick: evt => {
      evt.preventDefault();
      props.onClick(props.currentPage - 1);
    },
    role: "link"
  }, /*#__PURE__*/React.createElement(_Icon.Icon, {
    iconName: "ChevronLeft",
    className: styles.linkIcons
  }), props.label));
};

exports.PreviousLink = PreviousLink;

const Page = props => {
  const {
    page,
    onClick,
    isCurrent,
    ariaLabelNavigationLink,
    ariaLabelNavigationLinkActive
  } = props;
  const styles = (0, _Pagination.getClassNames)();

  const ariaLabel = () => {
    if (isCurrent) {
      return (ariaLabelNavigationLinkActive ? ariaLabelNavigationLinkActive : 'Side ') + page;
    }

    return (ariaLabelNavigationLink ? ariaLabelNavigationLink : 'Side ') + page;
  };

  return /*#__PURE__*/React.createElement("li", null, /*#__PURE__*/React.createElement("button", {
    onClick: evt => {
      evt.preventDefault();
      onClick(page);
    },
    className: isCurrent ? styles.activePage : styles.pageNumber,
    "aria-label": ariaLabel(),
    "aria-current": isCurrent,
    "aria-disabled": isCurrent,
    role: "link"
  }, page));
};

exports.Page = Page;

const Pages = props => {
  const pagesDisplayed = props.pagesDisplayed || 3;
  const windowEdges = getSlidingWindowEdges(props.currentPage, props.total, props.pageSize, pagesDisplayed);
  return /*#__PURE__*/React.createElement("div", null, range(windowEdges.startPage, windowEdges.endPage, pagesDisplayed).map(i => {
    return /*#__PURE__*/React.createElement(Page, {
      key: i,
      onClick: props.onPageChange,
      page: i,
      isCurrent: props.currentPage === i,
      ariaLabelNavigationLink: props.ariaLabelNavigationLink,
      ariaLabelNavigationLinkActive: props.ariaLabelNavigationLinkActive
    });
  }));
};

exports.Pages = Pages;