"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SearchField = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _react = require("@fluentui/react");

var _react2 = _interopRequireWildcard(require("react"));

var _SearchField = require("./SearchField.classNames");

var _i18next = _interopRequireDefault(require("i18next"));

var _utils = require("../utils");

var _LabelWithCallout = require("../LabelWithCallout");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const searchInList = (options, filterText) => {
  const regex = /[\s.,:-]+/g;
  return options.filter(option => {
    return option.text.replace(regex, '').toLowerCase().indexOf(filterText.replace(regex, '').toLowerCase()) > -1;
  }).map(option => option);
};

const limitNumberOfResults = (list, limit) => {
  if (limit && !isNaN(limit)) {
    return list.slice(0, limit);
  }

  return list;
};
/*
 * visibleName SearchField (Søkefelt)
 */


const SearchField = props => {
  const {
    className,
    help,
    id,
    label,
    labelButtonAriaLabel,
    labelWithCalloutProps,
    language,
    onCalloutToggle,
    onChange,
    onSelected,
    options,
    limit,
    keyboardShortcut = false,
    searchShortcutKeys = 'ctrl+f',
    onSearchIcon,
    searchIconTitle = 'Søk'
  } = props,
        rest = _objectWithoutProperties(props, ["className", "help", "id", "label", "labelButtonAriaLabel", "labelWithCalloutProps", "language", "onCalloutToggle", "onChange", "onSelected", "options", "limit", "keyboardShortcut", "searchShortcutKeys", "onSearchIcon", "searchIconTitle"]);

  const _searchBoxElement = /*#__PURE__*/(0, _react2.createRef)();

  const _componentRef = (0, _react2.useRef)(null);

  const [dropdownVisible, setDropdownVisible] = (0, _react2.useState)(false);
  const [searchResultList, setSearchResultList] = (0, _react2.useState)(options);
  const [value, setValue] = (0, _react2.useState)(props.value);
  const [focus, setFocus] = (0, _react2.useState)(-1);
  const [hasSelected, setHasSelected] = (0, _react2.useState)(false);
  const styles = (0, _SearchField.getClassNames)(props);
  const listRefs = (0, _react2.useRef)([]);
  const genratedId = (0, _utils.generateId)();
  const mainId = id ? id : 'searchfield-' + genratedId;
  const inputId = mainId + '-input';
  const labelId = mainId + '-label';
  const srFocus = mainId + '-srFocus';
  const resultsId = mainId + '-results';

  if (language) {
    _i18next.default.changeLanguage(language);
  }

  const setSearchResult = (0, _react2.useCallback)(newValue => {
    if (options && newValue && !hasSelected) {
      let newList = searchInList(options, newValue);
      newList = limitNumberOfResults(newList, limit);
      setSearchResultList(newList);
      setDropdownVisible(newList.length > 0);
      listRefs.current = [];
      setFocus(-1);
    }
  }, [limit, options, hasSelected]);
  (0, _react2.useEffect)(() => {
    setSearchResultList(options);
    setSearchResult(value ? value : '');
  }, [options, setSearchResult, value]);
  (0, _react2.useEffect)(() => {
    setValue(props.value);
  }, [props.value]);
  (0, _react2.useEffect)(() => {
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      // Unbind the event listener on clean up
      document.removeEventListener('mousedown', handleClickOutside);
    };
  });
  (0, _utils.useHotkeys)(searchShortcutKeys, ev => {
    if (keyboardShortcut) {
      ev.preventDefault();
      return _componentRef.current?.focus();
    }
  });

  const selectEvent = item => {
    setValue(!onSelected ? item.text : '');
    onSelected && onSelected(item);
    setHasSelected(true);
    setDropdownVisible(false);
    setFocus(-1);
    listRefs.current = [];
  };

  const handleOnKeyDown = ev => {
    if (dropdownVisible && listRefs.current) {
      let newFocus = focus;

      if (ev.key === 'ArrowUp') {
        ev.preventDefault();
        newFocus > 0 && newFocus--;
      } else if (ev.key === 'ArrowDown') {
        ev.preventDefault();
        newFocus < listRefs.current.length && newFocus++;
      } else if (ev.key === 'Escape') {
        setDropdownVisible(false);
        _componentRef.current && _componentRef.current.focus();
      }

      if (newFocus !== focus && newFocus <= listRefs.current.length - 1) {
        const focusItem = listRefs.current[newFocus];
        focusItem && focusItem.focus();
        setFocus(newFocus);
      }
    }
  };

  const handleClickOutside = event => {
    const contains = listRefs.current.filter(ref => ref && ref.contains(event.target));

    if (!contains.length && _searchBoxElement.current && !_searchBoxElement.current.contains(event.target)) {
      setDropdownVisible(false);
    }
  };

  const handleBlur = event => {
    if (event.relatedTarget && !event.currentTarget.contains(event.relatedTarget)) {
      if (!event.currentTarget.parentNode || !event.currentTarget.parentNode.contains(event.relatedTarget)) {
        setDropdownVisible(false);
      }

      setFocus(-1);
    }
  };

  const renderSuggestions = list => {
    if (list.length === 0) {
      listRefs.current = [];
    }

    return /*#__PURE__*/_react2.default.createElement("div", {
      className: styles.searchListDropdown,
      onBlur: handleBlur
    }, /*#__PURE__*/_react2.default.createElement("ul", {
      id: resultsId,
      role: "listbox",
      className: dropdownVisible && list.length ? styles.searchList : styles.hiddenUl
    }, list.map((listItem, key) => {
      return dropdownVisible ? /*#__PURE__*/_react2.default.createElement("li", {
        "aria-label": listItem.text,
        key: listItem.key,
        onClick: () => selectEvent(listItem),
        onFocus: () => {
          setFocus(key);
        },
        onKeyDown: ev => {
          if (ev.key === 'Enter' || ev.key === ' ') {
            selectEvent(listItem);
          } else {
            handleOnKeyDown(ev);
          }
        },
        ref: ref => {
          if (ref && listRefs.current.indexOf(ref) === -1) {
            listRefs.current.splice(key, 0, ref);
          }
        },
        tabIndex: 0,
        role: "option",
        "aria-selected": key === focus
      }, /*#__PURE__*/_react2.default.createElement("div", {
        title: listItem.text,
        className: styles.blackAlt,
        tabIndex: -1
      }, listItem.text)) : null;
    })));
  };

  return /*#__PURE__*/_react2.default.createElement("div", {
    id: mainId
  }, /*#__PURE__*/_react2.default.createElement(_LabelWithCallout.LabelWithCallout, _extends({
    id: labelId,
    label: label,
    buttonAriaLabel: labelButtonAriaLabel,
    inputId: inputId,
    help: help,
    onCalloutToggle: onCalloutToggle
  }, labelWithCalloutProps)), options ? /*#__PURE__*/_react2.default.createElement("div", {
    ref: _searchBoxElement
  }, /*#__PURE__*/_react2.default.createElement("span", {
    id: srFocus,
    className: styles.srOnly
  }, (0, _utils.t)('searchfield.sr.focus')), /*#__PURE__*/_react2.default.createElement(_react.SearchBox, _extends({}, rest, {
    onFocus: event => {
      event.target && event.target.select();
    },
    id: inputId,
    "aria-expanded": dropdownVisible,
    "aria-describedby": srFocus,
    "aria-owns": resultsId,
    type: 'search',
    className: (0, _classnames.default)(styles.main, className),
    onChange: (ev, newValue) => {
      onChange && onChange(ev, newValue);
      setHasSelected(false);

      if (!newValue) {
        setDropdownVisible(false);
      } else {
        setSearchResult(newValue);
      }

      setValue(newValue);
    },
    onKeyDown: ev => handleOnKeyDown(ev),
    value: value !== undefined ? value : '',
    componentRef: _componentRef,
    iconProps: {
      iconName: 'Filter',
      onClick: ev => onSearchIcon ? onSearchIcon(ev) : null
    }
  })), /*#__PURE__*/_react2.default.createElement("span", {
    "aria-live": "assertive",
    className: styles.srOnly
  }, dropdownVisible ? _i18next.default.t('searchfield.sr.results', {
    ant: searchResultList ? searchResultList.length : 0
  }) : ''), renderSuggestions(searchResultList)) : /*#__PURE__*/_react2.default.createElement(_react.SearchBox, _extends({
    type: 'search'
  }, props, {
    id: inputId,
    className: (0, _classnames.default)(styles.main, className),
    componentRef: _componentRef,
    showIcon: true,
    iconProps: {
      onClick: ev => onSearchIcon ? onSearchIcon(ev) : null,
      title: onSearchIcon ? searchIconTitle : ''
    }
  })));
};

exports.SearchField = SearchField;
SearchField.defaultProps = {
  border: 'default',
  searchFieldSize: 'standard'
};