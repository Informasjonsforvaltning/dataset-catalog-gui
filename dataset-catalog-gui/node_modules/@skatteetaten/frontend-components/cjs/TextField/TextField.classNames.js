"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getClassNames = void 0;

var _mergeStyles = require("@fluentui/merge-styles");

var _react = require("@fluentui/react");

var _utils = require("../utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getFieldTypeStyles(props) {
  if (props.inputSize === 'large') {
    return {
      '.ms-TextField-fieldGroup': {
        borderWidth: 2,
        minHeight: 42
      }
    };
  } else if (props.errorMessage) {
    return {
      '.ms-TextField-fieldGroup': {
        borderWidth: 2
      }
    };
  } else {
    return {
      '& .ms-TextField-field': {
        fontSize: _utils.FontSizes.medium
      }
    };
  }
}

const getClassNames = props => {
  const {
    boldText,
    borderless,
    calloutFloating,
    editableWhenEmpty,
    errorMessage,
    readOnly,
    underlined
  } = props;
  const {
    semanticColors
  } = (0, _react.getTheme)();
  const palette = (0, _react.getTheme)().palette;
  const errorIcon = "'" + _utils.SkeIcons.icons.Error + "'";
  const color = errorMessage ? palette.skeColor.error : palette.skeColor.blackAlt;
  return (0, _mergeStyles.mergeStyles)({
    displayName: 'SkeTextField',
    selectors: _objectSpread(_objectSpread({}, getFieldTypeStyles(props)), {}, {
      '&& .ms-TextField-fieldGroup': {
        borderRadius: '0px'
      },
      '& .ms-TextField-fieldGroup': readOnly && {
        border: 'none',
        outline: 'none',
        background: 'transparent'
      },
      '&& .ms-TextField-fieldGroup:focus': {
        border: props.errorMessage ? palette.skeColor.blue : palette.skeColor.error
      },
      '&.is-active .ms-TextField-fieldGroup': !borderless && !underlined && !readOnly && {
        border: `1px solid ${palette.skeColor.blue}`
      },
      // style customization for underlined model
      '&.ms-TextField--underlined .ms-TextField-wrapper': {
        border: `1px solid ${color}`
      },
      '&.ms-TextField--underlined .ms-TextField-wrapper:hover': {
        border: `1px solid ${semanticColors.inputBorderHovered}`
      },
      '&.is-active.ms-TextField--underlined .ms-TextField-wrapper': {
        border: `1px solid ${color}`,
        outline: `1px solid ${color}`
      },
      // Ikke lengre i bruk
      '& .ms-TextField-field[readOnly]': {
        paddingLeft: '1px',
        cursor: 'default',
        fontWeight: boldText ? _utils.FontWeights.bold : _utils.FontWeights.regular,
        border: 'none',
        outline: 'none',
        background: 'transparent'
      },
      '& .ms-TextField-field[readOnly]:focus': {
        fontWeight: boldText ? _utils.FontWeights.bold : _utils.FontWeights.regular
      },
      '&.is-active .ms-TextField-field': readOnly && {
        border: `1px solid ${palette.skeColor.blue}`,
        backgroundColor: palette.skeColor.white
      },
      '&.is-active .ms-TextField-field[readOnly]:focus': readOnly && {
        border: `none`,
        background: 'transparent'
      },
      '& .ms-TextField-field[disabled]': {
        color: palette.skeColor.darkGrey
      },
      '.ms-Button-icon': {
        fontSize: 18
      },
      '& .ms-TextField-errorMessage': {
        position: 'relative',
        color: palette.skeColor.error,
        fontWeight: _utils.FontWeights.medium,
        fontSize: _utils.FontSizes.small,
        paddingLeft: 20
      },
      '& .ms-TextField-errorMessage::before': {
        fontFamily: _utils.SkeIcons.fontFace.fontFamily,
        fontSize: 16,
        display: 'block',
        content: errorIcon,
        marginRight: 3,
        position: 'absolute',
        top: 6,
        left: 0
      },
      '& .ms-TextField-fieldGroup::before': {
        display: 'none'
      },
      'textarea.ms-TextField-field': {
        resize: 'none'
      },
      'input.ms-TextField-field': editableWhenEmpty && {
        border: '1px solid' + palette.skeColor.blackAlt,
        backgroundColor: palette.skeColor.white
      },
      '& .ms-Callout-main': typeof calloutFloating !== 'undefined' && !calloutFloating && {
        display: 'inline-block'
      },
      '.ms-TextField-suffix': !props.editMode && props.readOnly && {
        display: 'none'
      },
      '&.is-disabled .ms-TextField-fieldGroup': {
        borderColor: palette.skeColor.lightGrey,
        borderStyle: 'solid',
        borderWidth: '1px',
        backgroundColor: palette.skeColor.whiteGrey
      },
      '&.is-disabled .ms-TextField-field': {
        color: palette.skeColor.blackAlt
      },
      '&.is-disabled .ms-TextField-field:hover': {
        cursor: 'not-allowed'
      }
    })
  });
};

exports.getClassNames = getClassNames;