"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LabelWithCallout = void 0;

var React = _interopRequireWildcard(require("react"));

var _LabelWithCallout = require("./LabelWithCallout.classNames");

var _react2 = require("@fluentui/react");

var _Callout = require("../Callout");

var _LabelWithCallout2 = require("./LabelWithCallout.types");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
 * visibleName LabelWithCallout (Merkelapp med utropsboks)
 */
const LabelWithCallout = props => {
  const {
    id,
    inputId,
    label,
    ariaLabel,
    buttonAriaLabel,
    buttonTitle,
    calloutFloating = false,
    customClassNames,
    editable,
    requiredMark,
    editFunction,
    help,
    inFieldset,
    readOnly,
    warning,
    onRenderLabel,
    onCalloutToggle,
    calloutProps
  } = props;
  const styles = (0, _LabelWithCallout.getClassNames)(_objectSpread({
    calloutFloating
  }, props));
  const [isCalloutVisible, setIsCalloutVisible] = React.useState(false);
  const [currentCalloutState, setCurrentCalloutState] = React.useState(_LabelWithCallout2.calloutState.CLOSED);
  const iconButtonElementRef = React.useRef(null);
  const helpElement = /*#__PURE__*/React.isValidElement(help) ? help : /*#__PURE__*/React.createElement("p", {
    className: customClassNames?.helpPragraph ?? ''
  }, help);
  const warningElement = /*#__PURE__*/React.isValidElement(warning) ? warning : /*#__PURE__*/React.createElement("p", {
    className: customClassNames?.warningPragraph ?? ''
  }, warning);
  const requiredSymbol = requiredMark ? ' *' : '';

  const toggleEvent = () => {
    if (onCalloutToggle) {
      const oldCalloutState = currentCalloutState;
      const newCalloutState = isCalloutVisible ? _LabelWithCallout2.calloutState.CLOSED : _LabelWithCallout2.calloutState.OPEN;
      setCurrentCalloutState(newCalloutState);
      onCalloutToggle(oldCalloutState, newCalloutState);
    }

    return;
  };

  return onRenderLabel ? onRenderLabel : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: `${styles.calloutLabelWrapper} ${customClassNames?.wrapper ?? ''}`
  }, inFieldset ? label ? /*#__PURE__*/React.createElement("legend", {
    id: id,
    className: `${styles.labelAsLegend} ${customClassNames?.legend ?? ''}`,
    "aria-label": ariaLabel
  }, label + requiredSymbol) : null : label ? /*#__PURE__*/React.createElement("label", {
    id: id,
    htmlFor: inputId,
    className: `${styles.label} ${customClassNames?.label ?? ''}`,
    "aria-label": ariaLabel
  }, label + requiredSymbol) : null, help && !warning && /*#__PURE__*/React.createElement("span", {
    className: styles.labelIconArea,
    ref: iconButtonElementRef
  }, /*#__PURE__*/React.createElement(_react2.IconButton, {
    title: buttonTitle ? buttonTitle : 'Hjelp',
    iconProps: {
      iconName: 'HelpOutline'
    },
    className: `${styles.icon} ${customClassNames?.helpicon ?? ''}`,
    onClick: () => {
      setIsCalloutVisible(!isCalloutVisible);
      toggleEvent();
    },
    "aria-describedby": id,
    ariaLabel: buttonAriaLabel ? buttonAriaLabel : 'Hjelp',
    "aria-expanded": isCalloutVisible
  })), warning && /*#__PURE__*/React.createElement("span", {
    className: styles.labelIconArea,
    ref: iconButtonElementRef
  }, /*#__PURE__*/React.createElement(_react2.IconButton, {
    title: buttonTitle ? buttonTitle : 'Varsel',
    iconProps: {
      iconName: 'WarningOutline'
    },
    className: `${styles.warningicon} ${customClassNames?.warningicon ?? ''}`,
    onClick: () => {
      setIsCalloutVisible(!isCalloutVisible);
      toggleEvent();
    },
    "aria-describedby": id,
    ariaLabel: buttonAriaLabel ? buttonAriaLabel : 'Varsel',
    "aria-expanded": isCalloutVisible
  })), readOnly && /*#__PURE__*/React.createElement("span", {
    className: `${styles.labelIconArea} ${customClassNames?.readonlyarea ?? ''}`
  }, editable && /*#__PURE__*/React.createElement(_react2.IconButton, {
    title: buttonTitle ? buttonTitle : 'Rediger',
    iconProps: {
      iconName: 'Edit'
    },
    className: `${styles.icon} ${customClassNames?.editicon ?? ''}`,
    "aria-describedby": id,
    ariaLabel: buttonAriaLabel ? buttonAriaLabel : 'Rediger',
    "aria-expanded": isCalloutVisible,
    onClick: editFunction
  }))), isCalloutVisible && /*#__PURE__*/React.createElement(_Callout.Callout, _extends({}, calloutProps, {
    ref: calloutProps?.ref,
    className: `${styles.calloutContext} ${customClassNames?.callout ?? ''}`,
    color: help && !warning ? _Callout.Callout.HELP : _Callout.Callout.WARNING,
    target: iconButtonElementRef.current,
    directionalHint: calloutFloating ? _Callout.Callout.POS_BOTTOM_LEFT : _Callout.Callout.POS_TOP_LEFT,
    onClose: () => {
      setIsCalloutVisible(false);
      toggleEvent();
    },
    onDismiss: () => {
      if (calloutProps?.autoDismiss) {
        setIsCalloutVisible(false);
        toggleEvent();
      }
    }
  }), help && !warning ? helpElement : warningElement));
};

exports.LabelWithCallout = LabelWithCallout;