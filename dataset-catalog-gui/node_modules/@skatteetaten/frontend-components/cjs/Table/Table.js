"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setScrollBarState = exports.default = exports.Table = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _react = _interopRequireWildcard(require("react"));

var _Table = require("./Table.classNames");

var _utils = require("../utils");

var _TableRow = require("./TableRow");

var _SumRow = require("./SumRow");

var _TableHeader = require("./TableHeader");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const setScrollBarState = (wrapperWidth, tableWidth, setTableIsScrollable) => {
  if (tableWidth && wrapperWidth && tableWidth > wrapperWidth) {
    setTableIsScrollable(true);
  } else {
    setTableIsScrollable(false);
  }
};
/*
 * visibleName Table (Tabell)
 */


exports.setScrollBarState = setScrollBarState;

const Table = props => {
  const {
    id,
    customClassNames,
    editableRows,
    expandableRows,
    expandIconPlacement,
    children,
    columns,
    openEditableOnRowClick,
    showRowSeparators = true,
    compactTable = false,
    caption = null,
    hideCaption,
    openEditableRowIndex: OpenEditableRowIndexExternal,
    setOpenEditableRowIndex,
    openExpandableRowIndex: openExpandableRowIndexExternal,
    setOpenExpandableRowIndex,
    sum
  } = props;
  const genratedId = (0, _utils.generateId)();
  const mainId = id ? id : 'table-' + genratedId;

  const wrapperRef = _react.default.useRef(null);

  const tableRef = _react.default.useRef(null);

  const [tableIsScrollable, setTableIsScrollable] = (0, _react.useState)(false);
  const [openEditableRowIndexInternal, setOpenEditableRowIndexInternal] = (0, _react.useState)(OpenEditableRowIndexExternal);
  const [openExpandableRowIndexInternal, setOpenExpandableIndexInternal] = (0, _react.useState)();
  const [sort, setSort] = (0, _react.useState)({
    ascending: false,
    columnFieldName: ''
  });
  const styles = (0, _Table.getClassNames)(props);
  (0, _react.useEffect)(() => {
    if (setOpenEditableRowIndex) {
      setOpenEditableRowIndex(openEditableRowIndexInternal);
    }
  }, [openEditableRowIndexInternal, setOpenEditableRowIndex]);
  (0, _react.useEffect)(() => {
    setOpenEditableRowIndexInternal(OpenEditableRowIndexExternal);
  }, [OpenEditableRowIndexExternal]);
  (0, _react.useEffect)(() => {
    if (setOpenExpandableRowIndex) {
      setOpenExpandableRowIndex(openExpandableRowIndexInternal);
    }
  }, [openExpandableRowIndexInternal, setOpenExpandableRowIndex]);
  (0, _react.useEffect)(() => {
    setOpenExpandableIndexInternal(openExpandableRowIndexExternal);
  }, [openExpandableRowIndexExternal]);

  const updateDimensions = () => {
    const tableWidth = tableRef.current && tableRef.current.clientWidth;
    const wrapperWidth = wrapperRef.current && wrapperRef.current.clientWidth;
    setScrollBarState(wrapperWidth, tableWidth, value => setTableIsScrollable(value));
  };

  const sortRowData = rows => {
    const sortingKey = sort.columnFieldName;

    if (sortingKey) {
      const copiedArray = [...rows];
      const sortDescending = !sort.ascending;
      const sortingFunction = columns && columns.filter(column => column.fieldName === sortingKey)[0].sortingFunction;

      if (sortingFunction) {
        copiedArray.sort((a, b) => sortingFunction(a[sortingKey], b[sortingKey]));
      } else {
        copiedArray.sort(function (a, b) {
          return a[sortingKey] < b[sortingKey] ? -1 : 1;
        });
      }

      if (sortDescending) {
        copiedArray.reverse();
      }

      return copiedArray;
    }

    return rows;
  };

  const handleEditRow = index => {
    setOpenEditableRowIndexInternal(index);
  };

  const handleExpandRow = index => {
    setOpenExpandableIndexInternal(index);
  };

  const handleCloseRow = () => {
    setOpenEditableRowIndexInternal(undefined);
    setOpenExpandableIndexInternal(undefined);
  };

  const getRowData = () => {
    const items = sortRowData(props.data);
    return items.map((row, index) => {
      return /*#__PURE__*/_react.default.createElement(_TableRow.TableRow, {
        data: row,
        key: index,
        rowIndex: index,
        columns: columns,
        editableContent: props.editableContent,
        editableRows: props.editableRows,
        editModeActive: openEditableRowIndexInternal !== undefined,
        expandableContent: props.expandableContent,
        expandableModeActive: openExpandableRowIndexInternal !== undefined,
        expandableRows: props.expandableRows,
        expandIconPlacement: props.expandIconPlacement,
        tableHasScroll: tableIsScrollable,
        isEditableRowOpen: openEditableRowIndexInternal === index,
        isExpandableRowOpen: openExpandableRowIndexInternal === index,
        openEditableOnRowClick: openEditableOnRowClick,
        onEditRow: () => handleEditRow(index),
        onExpandRow: () => handleExpandRow(index),
        onCloseRow: handleCloseRow,
        openExpandableRowIndex: openExpandableRowIndexInternal,
        tableId: mainId,
        showRowSeparators: showRowSeparators,
        compactTable: compactTable,
        sum: sum
      });
    });
  };

  _react.default.useEffect(() => {
    const tableWidth = tableRef.current && tableRef.current.clientWidth;
    const wrapperWidth = wrapperRef.current && wrapperRef.current.clientWidth;
    setScrollBarState(wrapperWidth, tableWidth, setTableIsScrollable);
    window.addEventListener('resize', updateDimensions);
  }, []);

  const emptyTd = /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, editableRows && /*#__PURE__*/_react.default.createElement("td", {
    className: styles.emptyTd
  }), expandableRows && /*#__PURE__*/_react.default.createElement("td", {
    className: styles.emptyTd
  }));

  return /*#__PURE__*/_react.default.createElement("div", {
    ref: wrapperRef,
    id: id,
    className: (0, _classnames.default)(styles.SkeTable, customClassNames?.wrapper)
  }, /*#__PURE__*/_react.default.createElement("table", {
    className: (0, _classnames.default)(styles.tabell, customClassNames?.table)
  }, caption && /*#__PURE__*/_react.default.createElement("caption", {
    className: (0, _classnames.default)(styles.tabellCaption, customClassNames?.caption),
    style: hideCaption ? (0, _utils.getSrOnlyStyle)() : undefined
  }, caption), /*#__PURE__*/_react.default.createElement("thead", {
    className: (0, _classnames.default)(styles.tabellThead, customClassNames?.tabellThead)
  }, /*#__PURE__*/_react.default.createElement("tr", {
    className: (0, _classnames.default)(styles.tabellTheadRow, customClassNames?.tabellTheadRow)
  }, (tableIsScrollable || expandIconPlacement === 'before') && emptyTd, /*#__PURE__*/_react.default.createElement(_TableHeader.TableHeader, {
    compactTable: compactTable,
    columns: columns,
    sort: sort,
    setSort: value => setSort(value)
  }), !tableIsScrollable && expandIconPlacement !== 'before' && emptyTd)), /*#__PURE__*/_react.default.createElement("tbody", null, getRowData(), sum && /*#__PURE__*/_react.default.createElement(_SumRow.SumRow, {
    compactTable: compactTable,
    numberOfColumns: props.columns?.length ?? 0,
    editableRows: editableRows,
    expandableRows: expandableRows,
    expandIconPlacement: expandIconPlacement,
    sum: sum
  }))), children);
};

exports.Table = Table;
var _default = Table;
exports.default = _default;