function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import classnames from 'classnames';
import { SearchBox } from '@fluentui/react';
import React, { createRef, useCallback, useEffect, useRef, useState } from 'react';
import { getClassNames } from './SearchField.classNames';
import i18n from 'i18next';
import { generateId, useHotkeys, t } from '../utils';
import { LabelWithCallout } from '../LabelWithCallout';

const searchInList = (options, filterText) => {
  const regex = /[\s.,:-]+/g;
  return options.filter(option => {
    return option.text.replace(regex, '').toLowerCase().indexOf(filterText.replace(regex, '').toLowerCase()) > -1;
  }).map(option => option);
};

const limitNumberOfResults = (list, limit) => {
  if (limit && !isNaN(limit)) {
    return list.slice(0, limit);
  }

  return list;
};
/*
 * visibleName SearchField (Søkefelt)
 */


export const SearchField = props => {
  const {
    className,
    help,
    id,
    label,
    labelButtonAriaLabel,
    labelWithCalloutProps,
    language,
    onCalloutToggle,
    onChange,
    onSelected,
    options,
    limit,
    keyboardShortcut = false,
    searchShortcutKeys = 'ctrl+f',
    onSearchIcon,
    searchIconTitle = 'Søk'
  } = props,
        rest = _objectWithoutProperties(props, ["className", "help", "id", "label", "labelButtonAriaLabel", "labelWithCalloutProps", "language", "onCalloutToggle", "onChange", "onSelected", "options", "limit", "keyboardShortcut", "searchShortcutKeys", "onSearchIcon", "searchIconTitle"]);

  const _searchBoxElement = /*#__PURE__*/createRef();

  const _componentRef = useRef(null);

  const [dropdownVisible, setDropdownVisible] = useState(false);
  const [searchResultList, setSearchResultList] = useState(options);
  const [value, setValue] = useState(props.value);
  const [focus, setFocus] = useState(-1);
  const [hasSelected, setHasSelected] = useState(false);
  const styles = getClassNames(props);
  const listRefs = useRef([]);
  const genratedId = generateId();
  const mainId = id ? id : 'searchfield-' + genratedId;
  const inputId = mainId + '-input';
  const labelId = mainId + '-label';
  const srFocus = mainId + '-srFocus';
  const resultsId = mainId + '-results';

  if (language) {
    i18n.changeLanguage(language);
  }

  const setSearchResult = useCallback(newValue => {
    if (options && newValue && !hasSelected) {
      let newList = searchInList(options, newValue);
      newList = limitNumberOfResults(newList, limit);
      setSearchResultList(newList);
      setDropdownVisible(newList.length > 0);
      listRefs.current = [];
      setFocus(-1);
    }
  }, [limit, options, hasSelected]);
  useEffect(() => {
    setSearchResultList(options);
    setSearchResult(value ? value : '');
  }, [options, setSearchResult, value]);
  useEffect(() => {
    setValue(props.value);
  }, [props.value]);
  useEffect(() => {
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      // Unbind the event listener on clean up
      document.removeEventListener('mousedown', handleClickOutside);
    };
  });
  useHotkeys(searchShortcutKeys, ev => {
    if (keyboardShortcut) {
      ev.preventDefault();
      return _componentRef.current?.focus();
    }
  });

  const selectEvent = item => {
    setValue(!onSelected ? item.text : '');
    onSelected && onSelected(item);
    setHasSelected(true);
    setDropdownVisible(false);
    setFocus(-1);
    listRefs.current = [];
  };

  const handleOnKeyDown = ev => {
    if (dropdownVisible && listRefs.current) {
      let newFocus = focus;

      if (ev.key === 'ArrowUp') {
        ev.preventDefault();
        newFocus > 0 && newFocus--;
      } else if (ev.key === 'ArrowDown') {
        ev.preventDefault();
        newFocus < listRefs.current.length && newFocus++;
      } else if (ev.key === 'Escape') {
        setDropdownVisible(false);
        _componentRef.current && _componentRef.current.focus();
      }

      if (newFocus !== focus && newFocus <= listRefs.current.length - 1) {
        const focusItem = listRefs.current[newFocus];
        focusItem && focusItem.focus();
        setFocus(newFocus);
      }
    }
  };

  const handleClickOutside = event => {
    const contains = listRefs.current.filter(ref => ref && ref.contains(event.target));

    if (!contains.length && _searchBoxElement.current && !_searchBoxElement.current.contains(event.target)) {
      setDropdownVisible(false);
    }
  };

  const handleBlur = event => {
    if (event.relatedTarget && !event.currentTarget.contains(event.relatedTarget)) {
      if (!event.currentTarget.parentNode || !event.currentTarget.parentNode.contains(event.relatedTarget)) {
        setDropdownVisible(false);
      }

      setFocus(-1);
    }
  };

  const renderSuggestions = list => {
    if (list.length === 0) {
      listRefs.current = [];
    }

    return /*#__PURE__*/React.createElement("div", {
      className: styles.searchListDropdown,
      onBlur: handleBlur
    }, /*#__PURE__*/React.createElement("ul", {
      id: resultsId,
      role: "listbox",
      className: dropdownVisible && list.length ? styles.searchList : styles.hiddenUl
    }, list.map((listItem, key) => {
      return dropdownVisible ? /*#__PURE__*/React.createElement("li", {
        "aria-label": listItem.text,
        key: listItem.key,
        onClick: () => selectEvent(listItem),
        onFocus: () => {
          setFocus(key);
        },
        onKeyDown: ev => {
          if (ev.key === 'Enter' || ev.key === ' ') {
            selectEvent(listItem);
          } else {
            handleOnKeyDown(ev);
          }
        },
        ref: ref => {
          if (ref && listRefs.current.indexOf(ref) === -1) {
            listRefs.current.splice(key, 0, ref);
          }
        },
        tabIndex: 0,
        role: "option",
        "aria-selected": key === focus
      }, /*#__PURE__*/React.createElement("div", {
        title: listItem.text,
        className: styles.blackAlt,
        tabIndex: -1
      }, listItem.text)) : null;
    })));
  };

  return /*#__PURE__*/React.createElement("div", {
    id: mainId
  }, /*#__PURE__*/React.createElement(LabelWithCallout, _extends({
    id: labelId,
    label: label,
    buttonAriaLabel: labelButtonAriaLabel,
    inputId: inputId,
    help: help,
    onCalloutToggle: onCalloutToggle
  }, labelWithCalloutProps)), options ? /*#__PURE__*/React.createElement("div", {
    ref: _searchBoxElement
  }, /*#__PURE__*/React.createElement("span", {
    id: srFocus,
    className: styles.srOnly
  }, t('searchfield.sr.focus')), /*#__PURE__*/React.createElement(SearchBox, _extends({}, rest, {
    onFocus: event => {
      event.target && event.target.select();
    },
    id: inputId,
    "aria-expanded": dropdownVisible,
    "aria-describedby": srFocus,
    "aria-owns": resultsId,
    type: 'search',
    className: classnames(styles.main, className),
    onChange: (ev, newValue) => {
      onChange && onChange(ev, newValue);
      setHasSelected(false);

      if (!newValue) {
        setDropdownVisible(false);
      } else {
        setSearchResult(newValue);
      }

      setValue(newValue);
    },
    onKeyDown: ev => handleOnKeyDown(ev),
    value: value !== undefined ? value : '',
    componentRef: _componentRef,
    iconProps: {
      iconName: 'Filter',
      onClick: ev => onSearchIcon ? onSearchIcon(ev) : null
    }
  })), /*#__PURE__*/React.createElement("span", {
    "aria-live": "assertive",
    className: styles.srOnly
  }, dropdownVisible ? i18n.t('searchfield.sr.results', {
    ant: searchResultList ? searchResultList.length : 0
  }) : ''), renderSuggestions(searchResultList)) : /*#__PURE__*/React.createElement(SearchBox, _extends({
    type: 'search'
  }, props, {
    id: inputId,
    className: classnames(styles.main, className),
    componentRef: _componentRef,
    showIcon: true,
    iconProps: {
      onClick: ev => onSearchIcon ? onSearchIcon(ev) : null,
      title: onSearchIcon ? searchIconTitle : ''
    }
  })));
};
SearchField.defaultProps = {
  border: 'default',
  searchFieldSize: 'standard'
};