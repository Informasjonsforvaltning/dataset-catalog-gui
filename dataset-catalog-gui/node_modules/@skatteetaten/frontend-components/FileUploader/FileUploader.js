function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import * as React from 'react';
import axios from 'axios';
import i18n, { t } from './../utils/i18n/i18n';
import { getClassNames } from './FileUploader.classNames';
import classnames from 'classnames';
import { ErrorMessage } from '../ErrorMessage';
import { Spinner } from '../Spinner';
import { Icon } from '../Icon';
import { LabelWithCallout } from '../LabelWithCallout';
import { Link } from '../Link';
import { useEffect, useRef, useState } from 'react';
import { generateId } from '../utils';
export const isCorrectFileFormat = (file, acceptedFilformats) => {
  if (!acceptedFilformats) {
    return true;
  }

  const fileExtention = file.name.toLowerCase().match(/\.[0-9a-z]+$/i);

  if (fileExtention && fileExtention[0]) {
    if (acceptedFilformats.indexOf(fileExtention[0]) > -1) {
      return true;
    }
  }

  return false;
};
const nonWordCharacterRegexp = /\W/g;
const fileNameRegex = /\.(?=[^.]+$)/;

const normalize = (file, invalidCharacterRegexp) => {
  const nameList = file.name.split(fileNameRegex);
  const fileName = nameList[0];
  const normalizedName = fileName.replace(invalidCharacterRegexp || nonWordCharacterRegexp, '_');
  return normalizedName.concat('.', nameList[1]);
};

var FilTyperNavn;

(function (FilTyperNavn) {
  FilTyperNavn["ExcelFile"] = "ExcelFile";
  FilTyperNavn["WordFile"] = "WordFile";
  FilTyperNavn["PDFFile"] = "PDFFile";
  FilTyperNavn["XMLFile"] = "XMLFile";
  FilTyperNavn["File"] = "File";
})(FilTyperNavn || (FilTyperNavn = {}));

const filtypeMap = (() => {
  const map = new Map();
  map.set('xls', FilTyperNavn.ExcelFile);
  map.set('xlsx', FilTyperNavn.ExcelFile);
  map.set('doc', FilTyperNavn.WordFile);
  map.set('docx', FilTyperNavn.WordFile);
  map.set('pdf', FilTyperNavn.PDFFile);
  map.set('xml', FilTyperNavn.XMLFile);
  return map;
})();

const getFileIconName = fil => {
  const filutvidelse = fil.name.toLowerCase().split('.').pop();
  const fileType = filtypeMap.get(filutvidelse ? filutvidelse : '');
  return fileType ? fileType : FilTyperNavn.File;
};

export const FileUploader = props => {
  const {
    acceptedFileFormats,
    acceptedFileFormatsLabel,
    addFileString,
    afterUpload,
    axiosPath,
    className,
    deleteAllFiles,
    deleteButtonAriaLabel,
    deleteFile,
    exceedFileSizeLimitErrorMessage,
    files,
    fileSizeLimit,
    help,
    id,
    info,
    required = false,
    invalidCharacterRegexp,
    isLoading,
    label,
    labelButtonAriaLabel,
    labelWithCalloutProps,
    language,
    loading,
    multipleFiles,
    normalizeFileName,
    onCalloutToggle,
    queryParams,
    uploadFile,
    downloadFile
  } = props;
  const styles = getClassNames(props);
  const [internalFiles, setInternalFiles] = useState(files ? files : []);
  const [internalErrorMessages, setInternalErrorMessages] = useState([]);
  const [internalLoading, setInternalLoading] = useState(false);
  const inputRef = useRef(null);
  const uploadAreaRef = useRef(null);
  const randomId = generateId();
  const mainId = id ?? 'fileupload-' + randomId;
  const calloutId = mainId + '-callout';
  const fileuploadLabelId = mainId + '-label';
  const acceptedFileFormatsId = mainId + '-acceptedFileFormats';
  const informationId = mainId + '-information';

  if (language) {
    i18n.changeLanguage(language);
  }

  useEffect(() => {
    if (files) {
      setInternalFiles(files);
    }
  }, [files]);

  const pushToInternalMessages = msg => setInternalErrorMessages(prevState => [...prevState, msg]);

  const handleFileChange = event => {
    event.preventDefault();
    event.stopPropagation();

    if (event.target.files && event.target.files.length > 0) {
      handleNewFiles(Array.from(event.target.files));
    } // Må set input verdi til "" så at det er mulig å opplaste samme fil etter den blir fjernes i Chrome


    event.target.value = '';
  };

  const triggerUpdateFiles = validFiles => {
    if (uploadFile) {
      validFiles.forEach(file => {
        uploadFile(file);
      });
    }
  };

  const uploadFilePromise = (url, file, params) => {
    const formData = new FormData();
    formData.append('upload', file, normalizeFileName ? normalize(file, invalidCharacterRegexp) : undefined);
    return axios.post(url, formData, {
      params
    });
  };

  const isValidFile = (file, sizeLimit) => isCorrectFileFormat(file, acceptedFileFormats) && (sizeLimit ? file.size <= sizeLimit : true);

  const handleNewFiles = fileList => {
    setInternalErrorMessages([]);
    const exceedSizeLimitFiles = fileSizeLimit ? fileList.filter(file => file.size > fileSizeLimit) : [];

    if (fileSizeLimit && exceedSizeLimitFiles.length) {
      pushToInternalMessages(exceedFileSizeLimitErrorMessage || createDefaultOversizedFileErrorMessage(fileSizeLimit));
    }

    const invalidFileFormatFiles = fileList.filter(file => !isCorrectFileFormat(file, acceptedFileFormats));

    if (invalidFileFormatFiles.length) {
      pushToInternalMessages(t('fileuploader.error.file_format'));
    }

    const validFiles = fileList.filter(file => isValidFile(file, fileSizeLimit));
    triggerUpdateFiles(validFiles);

    if (!axiosPath) {
      return;
    }

    if (validFiles && validFiles.length) {
      setInternalLoading(true);
      const allPromises = validFiles.map(file => uploadFilePromise(axiosPath, file, queryParams));
      setTimeout(() => {
        axios.all(allPromises).then(responses => {
          const updatedInternalFiles = [...internalFiles, ...responses.map(res => res.data)];
          setInternalFiles(updatedInternalFiles);

          if (afterUpload) {
            afterUpload(updatedInternalFiles);
          }
        }).catch(error => {
          //TODO: Det trenger design om flere feilmeldinger
          if (error.response && error.response.status === 403) {
            pushToInternalMessages(t('fileuploader.error.upload.403'));
          } else {
            pushToInternalMessages(t('fileuploader.error.upload.general'));
          }

          if (afterUpload) {
            afterUpload(internalFiles);
          }
        }).finally(() => {
          setInternalLoading(false);
        });
      }, props.forsinkelse || 0);
    }
  };

  const createDefaultOversizedFileErrorMessage = filstoerrelsegrense => i18n.t('fileuploader.error.file_size', {
    filstoerrelsegrense: bitToMegabyte(filstoerrelsegrense)
  });

  const bitToMegabyte = size => (size / (1024 * 1024)).toFixed(1);

  const handleDragOverAndDragEnter = event => {
    event.preventDefault();
    event.stopPropagation();
  };

  const handleDragLeave = event => {
    event.preventDefault();
    event.stopPropagation();
  };

  const handleDrop = event => {
    event.preventDefault();
    event.stopPropagation();

    if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length > 0) {
      handleNewFiles(Array.from(event.dataTransfer.files));
    }
  };

  const showFileName = file => {
    if (downloadFile) {
      return /*#__PURE__*/React.createElement(Link, {
        tabIndex: 0,
        text: file.name,
        onClick: () => downloadFile(file)
      });
    } else {
      return /*#__PURE__*/React.createElement("span", null, file.name);
    }
  };

  const deleteFromList = fileToBeDeleted => {
    setInternalErrorMessages([]);

    if (axiosPath) {
      axios.delete(`${axiosPath}/${fileToBeDeleted.id}`, {
        params: queryParams,
        data: props.usesWebSealCompatibleDelete === true ? null : {} // body kreves av BigIP

      }).then(() => {
        const newList = internalFiles.filter(f => f.id !== fileToBeDeleted.id);
        setInternalFiles(newList);
        triggerUpdateFiles(newList);
      }).catch(error => {
        if (error.response && error.response.status === 403) {
          pushToInternalMessages(t('fileuploader.error.delete.403'));
        } else {
          pushToInternalMessages(t('fileuploader.error.delete.general'));
        }
      }).finally(() => {
        if (deleteFile) {
          deleteFile(fileToBeDeleted, internalErrorMessages);
        }
      });
    } else {
      if (deleteFile) {
        deleteFile(fileToBeDeleted, internalErrorMessages);
      }
    }

    const ref = uploadAreaRef.current;

    if (ref) {
      ref.focus();
    }
  };

  if (deleteAllFiles && files) {
    files.forEach(file => {
      deleteFromList(file);
    });
  }

  useEffect(() => {
    isLoading && isLoading(loading || internalLoading);
  }, [loading, internalLoading, isLoading]);
  return /*#__PURE__*/React.createElement("div", {
    className: classnames(styles.main, className)
  }, /*#__PURE__*/React.createElement(LabelWithCallout, _extends({
    id: calloutId + '-label',
    inputId: calloutId + '-input',
    label: label,
    requiredMark: required,
    buttonAriaLabel: labelButtonAriaLabel,
    help: help,
    onCalloutToggle: onCalloutToggle
  }, labelWithCalloutProps)), /*#__PURE__*/React.createElement("label", {
    id: fileuploadLabelId
  }, /*#__PURE__*/React.createElement("div", {
    ref: uploadAreaRef,
    className: styles.uploadArea,
    role: "button",
    "aria-describedby": fileuploadLabelId.concat(acceptedFileFormats ? ' '.concat(acceptedFileFormatsId) : '', info ? ' '.concat(informationId) : ''),
    tabIndex: 0,
    onDragEnter: handleDragOverAndDragEnter,
    onDragLeave: handleDragLeave,
    onDragOver: handleDragOverAndDragEnter,
    onDrop: handleDrop,
    onClick: event => {
      event.preventDefault();

      if (inputRef.current) {
        inputRef.current.click();
      }
    },
    onKeyPress: ev => {
      if (ev.keyCode === 0 && inputRef.current) {
        inputRef.current.click();
      }
    }
  }, loading || internalLoading ? /*#__PURE__*/React.createElement(Spinner, null) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Icon, {
    iconName: 'AttachFile',
    className: styles.uploadAreaIcon
  }), /*#__PURE__*/React.createElement("u", null, addFileString ? addFileString : t('fileuploader.add.label'))))), /*#__PURE__*/React.createElement("input", {
    className: styles.fileUploadInput,
    type: "file",
    id: calloutId + '-input',
    ref: inputRef,
    multiple: multipleFiles,
    onChange: handleFileChange,
    tabIndex: -1,
    "aria-hidden": true
  }), acceptedFileFormats && /*#__PURE__*/React.createElement("span", {
    className: styles.informationWrapper,
    id: acceptedFileFormatsId
  }, acceptedFileFormatsLabel ? acceptedFileFormatsLabel : t('fileuploader.accepted_file_formats'), ' ', /*#__PURE__*/React.createElement("span", {
    className: styles.acceptedFileFormats
  }, acceptedFileFormats.map((fileFormat, index) => {
    if (index === acceptedFileFormats.length - 1) {
      return fileFormat;
    } else {
      return fileFormat.concat(', ');
    }
  }))), info && /*#__PURE__*/React.createElement("div", {
    className: styles.informationWrapper,
    id: informationId
  }, info), internalErrorMessages && internalErrorMessages.map(msg => /*#__PURE__*/React.createElement("div", {
    key: msg
  }, /*#__PURE__*/React.createElement(ErrorMessage, null, msg))), /*#__PURE__*/React.createElement("div", {
    role: "alert",
    "aria-atomic": "true",
    className: styles.fileListWrapper
  }, internalFiles.length > 0 && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
    className: "sr-only"
  }, t('fileuploader.uploaded.sr_heading')), /*#__PURE__*/React.createElement("ul", {
    className: styles.fileList
  }, internalFiles.map((file, index) => /*#__PURE__*/React.createElement("li", {
    key: file.name.concat(index.toString())
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.fileName
  }, /*#__PURE__*/React.createElement(Icon, {
    className: styles.fileIcon,
    iconName: getFileIconName(file)
  }), showFileName(file)), file.error ? /*#__PURE__*/React.createElement(Icon, {
    iconName: 'Error',
    className: styles.errorColor
  }) : /*#__PURE__*/React.createElement("button", {
    className: styles.fileListCancelBtn,
    onClick: () => deleteFromList(file),
    "aria-label": deleteButtonAriaLabel ? deleteButtonAriaLabel : t('fileuploader.delete.ariaLabel')
  }, /*#__PURE__*/React.createElement(Icon, {
    iconName: 'Cancel'
  }))))))));
};